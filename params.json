{"name":"Oop.js","tagline":"OOP in javascript","body":"# oop.js\r\n\r\n用于创建通用类的模块\r\n\r\n## 特点\r\n\r\n* 子类构造函数和子类实例对象都可以通过`Super`属性访问到父类构造函数的prototype对象所指向的对象。方便复杂情况的调用。（比较拗口，看下面的代码就比较简单）\r\n* 使用`Parent`作为指向父类构造函数的`key`，语意更明确。\r\n* 支持`mixin`。\r\n* 压缩后小于1k。\r\n\r\n## 单测\r\n\r\n查看[单测](http://jias.github.io/oop.js/test/test.html)快速了解。\r\n\r\n## 语法\r\n\r\n#### 类定义\r\n\r\n`oop.create(config)`  \r\n`oop.create(config, statics)`\r\n\r\n* config: {Object} optional 原型方法\r\n\t- mixin: {Array} 合并可复用的对象的方法，所有从该类创建的实例都拥有该方法\r\n\t- _init: {Function} 初始化函数，注意，真正的构造函数是由Class返回的，init是被构造函数调用的\r\n\t- otherMethod: {Function} 其他自定义的原型方法\r\n* statics : {Object} optional 静态属性\r\n   - NAME: {String} 定义类的名称\r\n   - other: {Mixed} 其他自定义的静态属性或方法\r\n\r\nDemo: 定义一个`Person`类\r\n\r\n    var Person = oop.create({\r\n        _init : function (options) {\r\n            this.setName(options.name);\r\n        },\r\n        setName : function (name) {\r\n            this.name = 'person:' + name;\r\n        },\r\n        getName : function () {\r\n            return this.name;\r\n        }\r\n    },{\r\n        NAME : 'Person'\r\n    });\r\n\r\n    var person = new Person({\r\n        name : 'foo'\r\n    });\r\n    \r\n    person.getName(); // 'person:foo'\r\n\r\n\r\n#### 类继承\r\n\r\n`oop.create(parent, config)`  \r\n`oop.create(parent, config, statics)`\r\n\r\n* parent: {Class} 指定继承于哪个父类，若没有指定，则默认继承于Object对象\r\n* config: 同上。\r\n* statics: 同上。\r\n\r\nDemo: 定义一个类`Man`，它继承了`Person`类，并重写的`setName`方法。\r\n\r\n    var Man = oop.create(Person, {\r\n        _init : function (options) {\r\n            // 调用父类构造\r\n            Man.Super._init.call(this, options);\r\n            this.setTodo(options.todo);\r\n        },\r\n        // override method\r\n        setName : function (name) {\r\n            this.name = 'man:' + name;\r\n        },\r\n        // new method\r\n        setTodo : function (todo) {\r\n            this.todo = this.todo || [];\r\n            this.todo.push(todo);           \r\n        },\r\n        // new method\r\n        getTodo : function (stringify) {\r\n            return stringify ? this.todo.join(' / ') : this.todo;\r\n        }\r\n    },{\r\n        NAME : 'Man'\r\n    });\r\n\r\n    var man = new Man({\r\n        name : 'boo',\r\n        todo : 'Working Hard'\r\n    });\r\n    \r\n    man.getName(); // 'man:boo'\r\n    console.log(man.Super === Man.Super); // true\r\n\r\n#### 调用父类原型方法\r\n\r\n`.Super.method.call(this, options)`\r\n\r\n通过当前类，或当前类的实例的`Super`属性，都可以调用父类方法。即`Super`属性内部指向父类的prototype对象。\r\n\r\n    当前类的实例.Super.method.call(this, options);\r\n    当前类.Super.method.call(this, options);\r\n \r\nDemo: 定义一个类`Boy`，它继承了`Man`类，并重写的`setName`方法。\r\n\r\n    var Boy = oop.create(Man, {\r\n        mixin : [eve],\r\n        _init : function (options) {\r\n            Boy.Super._init.call(this, options);\r\n        },  \r\n        // override method\r\n        setName : function (name) {\r\n            this.name = 'boy:' + name;\r\n        },\r\n        // only for demo\r\n        getTodo2 : function () {\r\n            return Boy.Super.getTodo.call(this, true);\r\n        }\r\n    },{\r\n        NAME : 'Boy'\r\n    });\r\n    var boy = new Boy({\r\n        name : 'woo',\r\n        todo : 'Doing Homework'\r\n    });\r\n    \r\n\r\n【注意】：对于两层以上的继承，`this.Super.xxx`写法必定导致死循环。如上面的示例中，`Boy`继承了`Man`，`Man`继承了`Person`，构成了两层继承，所以`Boy`类在调用父类方法时，应该使用`Boy.Super._init`调用父类构造方法。\r\n\r\n    _init : function () {\r\n        this.Super._init.call(this, options); // 导致死循环\r\n    } \r\n   \r\n#### 调用父类静态方法/属性\r\n\r\n`.Parent.method()`/`.Parent.attribute`\r\n\r\n通过当前类的`Parent`属性，可以调用父类的静态属性或方法。即`Parent`属性内部指向父类的构造函数。\r\n\r\n    当前类.Parent.method()\r\n    当前类.Parent.attribute\r\n\r\n\r\n## 更新记录\r\n\r\n* 2013-07-27 : \r\n    - 创建文档\r\n* 2013-08-14 : \r\n    - 添加调用父类原型方法和静态属性的说明\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}